# LCD

## 1. 背景

  总所周知，七彩虹Vulcan火神显卡，会自带一个小屏幕。我这边购买的是5080显卡，这个小屏幕还能摆在桌面当摆件。

  ![image](https://github.com/user-attachments/assets/0ec68c83-3331-4e39-bd12-565c446ae1a0)

  但是，**这个屏幕当前只能通过iGame Center控制软件**，进行显示控制。但是当我想用它来做一些监控使用，还差一些数据的可控呈现方式。所以需要通信协议，并在可以的范围内让屏幕显示自定义数据内容。

## 2. 示例效果
  我这边是使用的SerialPortMonitor5.0工具，直接抓取COM口数据，得到的其中一个显示方式的通信协议。如果需要其他显示方式的通信协议，可以自行摸索。

  原始显示内容：  
  ![image](https://github.com/user-attachments/assets/35e1ca6b-86be-4f30-86b3-63a5b3e6ac71)  
  使用自定义协议后，显示的内容：  
  ![image](https://github.com/user-attachments/assets/54a7eca4-9fe2-4719-9189-61d48697e9fc)

  可以看到，title部分不再显示型号，而是增加了几个自定义数据的显示。我这边用来显示利用率、风扇转速、温度等等数据。让小屏幕的实用性稍稍加强了些：）  
  你也可以把它改为“I LOVE YOU”之类的土味情话...

## 3. 通信协议
1. com端口号

  COM号码可以直接在Windows的设备管理器里查看。

2. 通信属性

		BaudRate：CBR_115200；
		ByteSize：8；
		Parity：NOPARITY；
		StopBits：ONESTOPBIT；
		timeouts：50ms；

3. 交互协议

		step 1. 电脑发送：{0x5A, 0x9F, 0xA9, 0x00, 0x04, 0xE0, 0x1F, 0x02, 0xA5}  
		step 2. 电脑接收：{0x5A, 0x9F, 0xA9, 0x00, 0x0C, 0xE0, 0x1F, 0x0A, 0x00, 0x05, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x02, 0xC9}  
		step 3. 电脑发送：{0x5A, 0x9F, 0xA9, 0x00, 0x05, 0xEC, 0x13, 0x01, 0x02, 0xA7}  
		step 4. 电脑发送：{0x5A, 0x9F, 0xA9, 0x00, 0x05, 0xEB, 0x14, 0x00, 0x02, 0xA6}  
		step 5. 电脑发送：{0x5A, 0x9F, 0xA9, 0x00, 0x06, 0xE1, 0x1E, 0x64, 0x00, 0x03, 0x0B}  
		step 6. 电脑发送：{0x5A, 0x9F, 0xA9, 0x00, 0x06, 0xE1, 0x1E, 0x0A, 0x00, 0x02, 0xB1}  
		step 7. 电脑发送：{0x5A, 0x9F, 0xA9, 0x00, 0x0F, 0xDD, 0x22, 0x07, 0xE9, 0x05, 0x0A, 0x06, 0x12, 0x33, 0x28, 0x01, 0x00, 0x02, 0x04, 0x25}  
		step 8. 电脑发送：{0x5A, 0x9F, 0xA9, 0x00, 0x1F, 0xDD, 0x22, 0x07, 0xE9, 0x05, 0x0A, 0x06, 0x12, 0x33, 0x2A, 0x01, 0x47, 0x45, 0x46, 0x4F, 0x52, 0x43, 0x45, 0x20, 0x52, 0x54, 0x58, 0x20, 0x35, 0x30, 0x38, 0x30, 0x00, 0x02, 0x08, 0x3D}  
		step 9. 每隔1秒重复step 8内容。  

## 4. 协议解析

  step1-6的协议内容，在当前的这个**显示时间的模式**下，可认为它就是是固定的，这里不做解析。  
  这里重点解析step 7、step 8电脑发送的数据包格式，以便于大家按需自定义屏幕的显示。
	
  这里step 7、step 8发送的数据包其实是相同的格式，只是step 7不带title数据，step 8带了title数据而已。以step 8中的数据为例，解析出协议的格式为：

<center><strong>COM口数据协议表</strong></center>

|偏移	|长度 (字节)|	内容|	说明|
| ----  | ---- | ---- | ---- |
|0-2	|3|	帧头 0x5A 0x9F 0xA9	|固定帧头标识，确保帧同步|
|3	|1	|帧序号 #1 0x00	|第一序号；递增用于丢包检测或应答匹配|
|4	|1	|数据长度 0x1F	|表示字节 5-35 共 31 B（数据区 + 校验）|
|5-6	|2|	固定ID 0xDD 0x22	|固定值 0x22DD|
|7-8	|2|	年 0x07 0xE9	|2025年|
|9	|1	|月 0x05	|5 月|
|10	|1	|日 0x0A	|10 日|
|11	|1	|星期 0x06	|0=周日…6=周六，表示周六|
|12	|1	|时 0x12	|18 时|
|13	|1	|分 0x33	|51 分|
|14	|1	|秒 0x2A	|42 秒|
|15	|1	|帧序号 #2 0x01	|第二序号；在帧序号 #1 的值上加1|
|16-32	|17|	ASCII 字符串 “GEFORCE RTX 5080”	|设备型号，17 B，含空格和结尾 0x00|
|33	|1	|显示版本 0x02	|0x00是默认版本，0x01是kudan版，0x02是vulcan版|
|34-35	|2|	16 位累加校验 0x08 0x3D	|Little-Endian；对字节 0-33 取累加和的低 16 位|

  这里**序号 #2**后面的内容就是title，我们可以自定义进行显示。例如示例效果中，是将被监控的系统数据发送到LCD屏幕上。  
  官方的iGame Center控制软件是每隔1秒发送一次数据包，所以数据刷新率是1秒。实测也可以每隔2秒或5秒发送一次数据包，进行LCD屏幕刷新。数据包的发送频率不会影响LCD的时间更新。

## 5. 补充说明
1. 目前就只发现了title可以自定义。并且支持显示的内容仅包括：大写字母A-Z、数字0-9、小数点. 。不支持#!@|%℃等符号，如果你有方法欢迎留言告诉我。
2. title的长度不是固定的，但最大支持25个字符，超出LCD不显示。协议里第五位值是含时间的数据总长度。
3. 关机前，一定要close掉COM句柄。否则下次开机可能会有COM口异常。

## 6. 源码包含这些功能：
a. 从系统读取COM端口号，并监控LCD接入事件；(main.cpp源文件)  
b. 实时从HWiNFO中读取负载、风扇转速、温度数据；(hwinfo.cpp源文件)  
c. 将数据同步到LCD屏幕显示；(com.cpp源文件)  

# 欢迎star~
